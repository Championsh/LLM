The sf_terminate_path specfunction denotes that the current execution path is terminated (with calling exit-like functions, an infinite loop or crashes).
The sf_overwrite and sf_overwrite_int_as_ptr functions are used to specify the assignment of values to memory locations or variables, aiding in denoting overwritten memory via pointers, describing new variable initializations, and are essential for accurate static analysis within tools like Svace; for instance, in double modf(double x, double *iptr) { sf_overwrite(iptr); } to indicate overwritten memory, and in ssize_t recv(int s, void *buf, size_t len, int flags) { ssize_t res; sf_overwrite(&res); sf_set_possible_negative(res); return res; } to portray variable initialization.
The sf_handle_acquire and sf_handle_acquire_int_as_ptr functions are used to validate the acquisition of specific resources (e.g., files or handles) using categorized resource types, while sf_handle_release verifies their appropriate release, maintaining error-free resource management; for example, utilizing these functions in file handling fopen and fclose ensures accurate resource acquisition and release validation.
These conditional acquire functions, such as sf_not_acquire_if_eq, sf_not_acquire_if_less, and sf_not_acquire_if_greater, are utilized to model situations where resources like memory or handles are not created under specific conditions, ensuring accurate error handling with code validation; for example, using sf_not_acquire_if_eq in fopen ensures that the resource is not created if it equals null, while sf_not_acquire_if_less_int_as_ptr is used in the open function to indicate that a new resource is created and that if it is less than 3, it was not created, matching common behavior where the original function returns -1 in case of an error and positive values indicate success, omitting the need to release handles 0, 1, and 2 used for stdin, stdout, and stderr.
The sf_invalid_pointer function is used to mark a pointer as invalid if it is not equal to a specified new pointer, as demonstrated in the memory reallocation function realloc(void *ptr, size_t size) { void *retptr; sf_invalid_pointer(ptr, retptr); return retptr; } where the result is marked as invalid if the new memory is not equal to the original pointer; meanwhile, the sf_escape function is used to indicate that a pointer and its referenced memory have escaped and can be stored or deleted without triggering memory leak warnings, as seen in the putenv(char *cmd) { sf_escape(cmd); } function where the stored parameter does not trigger leak warnings.
The sf_use_format function is used to indicate that its argument is a printf-like format string and should not receive tainted arguments, as illustrated in the fprintf function employing this specfunction to ensure the integrity of the format string. Conversely, the sf_set_trusted_sink_int, sf_set_trusted_sink_char, and sf_set_trusted_sink_ptr specfunctions are used to mark parameters as being involved in vulnerable operations and require bounds checking, with examples including ensuring the secure usage of integer and character types, including memory allocation, and vulnerable operations like execl.
The sf_buf_size_limit function is utilised to specify permissible buffer access within defined bounds, ensuring secure buffer handling, as demonstrated in functions such as fgets, snprintf, and strncat to prevent buffer overflows and ensure access stays within the prescribed limits, while sf_buf_size_limit_strict enforces strict buffer limit checks, enabling comprehensive monitoring of buffer sizes and parameter values in functions like memcpy_s to mitigate potential overflows and ensure parameter values remain within defined buffer bounds.
The sf_set_possible_negative function is used to specify that its integer parameter may hold negative values, requiring checks before buffer access and in functions that cannot accommodate negative values, as depicted in the putchar function, where the return value is marked as potentially negative.
The sf_set_must_be_positive function is designed to declare that its integer parameter cannot be negative but can be zero, as demonstrated in the dup function wherein the parameter oldd is required to be non-negative.
The sf_bitcopy function is employed to initialize the memory pointed to by dst with the content of src, often used in functions like memcpy for memory copying tasks, while sf_bitinit and sf_deepinit mark values and reachable memory as fully initialized respectively, with sf_deepinit initializing nested structures, as seen in recvmsg where sf_deepinit initializes not only the msg parameter but also its fields and nested structures.